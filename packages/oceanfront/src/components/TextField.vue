<template>
  <of-field-outer v-bind="fieldAttrs">
    <input ref="elt" v-bind="attrs" />
  </of-field-outer>
</template>

<script lang="ts">
import { ref, defineComponent, SetupContext, computed, Ref, watch } from 'vue'
import OfFieldOuter from './FieldOuter.vue'
import { useConfig } from '../lib/config'
import { NumberFormatter, ValueFormatter } from '../lib/format'

// const copyAttrs = new Set(['autocomplete', 'placeholder', 'size', 'value'])

// types that can be inherited from state.type
// setting state.inputType allows any value
const allowInputTypes = new Set([
  'date',
  'datetime-local',
  'email',
  'month',
  'number',
  'password',
  'tel',
  'time',
  'week',
  'url'
])

const inputTypeFrom = (type?: string) => {
  if (type && allowInputTypes.has(type)) return type
  return 'text'
}

export default defineComponent({
  name: 'of-text-field',
  components: { OfFieldOuter },
  inheritAttrs: false,
  props: {
    class: String,
    disabled: Boolean,
    format: [String, Function, Object],
    id: String,
    label: String,
    maxlength: Number,
    modelValue: [String, Number, Date],
    name: String,
    placeholder: String,
    readonly: Boolean,
    value: String,
    variant: String
  },
  setup(props, ctx: SetupContext) {
    const config = useConfig()
    const formatter = computed<ValueFormatter | undefined>(() => {
      let fmtCtor
      if (typeof props.format === 'string') {
        // FIXME look up registered formatter
        fmtCtor = (c: any) => new NumberFormatter(c)
      } else if (typeof props.format === 'function') {
        fmtCtor = props.format
      } else if (typeof props.format === 'object') {
        return props.format as ValueFormatter
      }
      if (fmtCtor) return fmtCtor(config)
    })
    let initValue = props.value === undefined ? props.modelValue : props.value
    const stateValue = ref(initValue)
    if (formatter.value) {
      initValue = formatter.value.format(initValue)
    }
    const inputValue = ref(initValue)
    watch(
      () => props.modelValue,
      val => {
        inputValue.value = val
      }
    )
    const elt = ref<HTMLInputElement | undefined>()
    const disabled = computed(() => props.disabled)
    const focused = ref(false)
    const readonly = computed(() => props.readonly && !disabled.value)
    const id = props.id || 'input-' + Math.round(Math.random() * 1000) // FIXME
    const value: Ref<any> = computed({
      get: () => {
        // FIXME format stored value
        // computed() can be generated by the formatter
        inputValue.value
      },
      set: (val: any) => {
        // FIXME unformat value
        inputValue.value = val
      }
    })
    const formatValue = computed(() => {
      if (formatter.value) return formatter.value.format(stateValue.value)
      return inputValue.value
    })
    watch(
      () => formatValue.value,
      fmtVal => {
        if (!focused.value && elt.value) {
          elt.value.value = fmtVal as string
        }
      }
    )
    const blank = computed(() => {
      // FIXME ask formatter
      const val = inputValue.value
      return val === undefined || val === null || val === ''
    })
    const fieldAttrs = computed(() => ({
      blank: blank.value,
      class: ['of-field-text', props.class],
      disabled: disabled.value,
      focused: focused.value,
      inputId: id,
      label: props.label,
      readonly: readonly.value,
      variant: props.variant
    }))
    const attrs = computed(() => ({
      id,
      class: 'of-field-input',
      disabled: disabled.value,
      inputmode: formatter.value?.inputMode,
      maxlength: props.maxlength,
      name: props.name,
      placeholder: props.placeholder,
      readonly: readonly.value,
      value: initValue,
      onBlur(evt: FocusEvent) {
        focused.value = false
      },
      onChange(evt: Event) {
        if (formatter.value) {
          inputValue.value = formatter.value.format(elt.value?.value)
          return
        }
        inputValue.value = elt.value?.value
      },
      onFocus(evt: FocusEvent) {
        focused.value = true
      },
      onInput(evt: InputEvent) {
        if (formatter.value) {
          const upd = formatter.value.handleInput(evt)
          if (upd) {
            if (!upd.updated) return
            elt.value!.value = upd.value!
            elt.value!.setSelectionRange(upd.selStart!, upd.selEnd!)
            stateValue.value = upd.nativeValue
          }
        }
        // inputValue.value = elt.value?.value // FIXME - makes safari jump to end of input
        // will become update:modelInput with modelValue bound to change event
        ctx.emit('update:modelValue', inputValue.value)
      },
      onKeydown(evt: KeyboardEvent) {
        if (formatter.value) {
          formatter.value.handleKeyDown(evt)
        }
      }
    }))
    return {
      attrs,
      elt,
      fieldAttrs
    }
  }
})
</script>
