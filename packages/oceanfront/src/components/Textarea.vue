<template>
  <of-field-outer v-bind="fieldAttrs">
    <textarea
      ref="elt"
      v-bind="attrs"
      v-on="handlers"
      :value="inputValue"
    ></textarea>
  </of-field-outer>
</template>

<script lang="ts">
import {
  ref,
  defineComponent,
  SetupContext,
  reactive,
  computed,
  Ref
} from 'vue'
import { FieldConfig, FieldState, fieldState } from '../lib/field'
import { StoreRef, storeRef } from '../lib/store'
import { hasOwn } from '../lib/util'
import OfFieldOuter from './FieldOuter.vue'

const copyAttrs = new Set([
  'autocomplete',
  'placeholder',
  'cols',
  'rows',
  'tabIndex',
  'value'
])

const calcHeight = (input: Ref<HTMLTextAreaElement>) => {
  let ht = input.value && input.value.scrollHeight
  console.log('height', ht)
}

export default defineComponent({
  name: 'of-textarea',
  components: { OfFieldOuter },
  inheritAttrs: false,
  setup(
    props: {
      class?: string // or object or list
      config?: FieldConfig
      disabled?: boolean
      id?: string
      placeholder?: string
      readonly?: boolean
      rows?: number
      store?: StoreRef
      value?: string
      variant?: string
      [key: string]: any
    },
    ctx: SetupContext
  ) {
    // FIXME avoid duplication from input-text
    const config = props.config || {}
    const initValue = props.value === undefined ? config.value : props.value
    const store = props.store || storeRef(initValue)
    const elt = ref<HTMLInputElement | undefined>()
    const disabled = computed(() => config.disabled || props.disabled)
    const focused = ref(false)
    const readonly = computed(
      () => (config.readonly || props.readonly) && !disabled.value
    )
    const id =
      props.id || config.id || 'input-' + Math.round(Math.random() * 1000) // FIXME
    const value: Ref<any> = computed({
      get: () => {
        // FIXME format stored value
        // computed() can be generated by the formatter
        store.value
      },
      set: (val: any) => {
        // FIXME unformat value
        store.value = val
      }
    })
    const inputValue = ref(initValue)
    const handlers = {
      blur: (evt: FocusEvent) => {
        focused.value = false
      },
      change: (evt: Event) => {
        inputValue.value = elt.value?.value
        store.value = elt.value?.value
      },
      input: (evt: InputEvent) => {
        inputValue.value = elt.value?.value
      },
      focus: (evt: FocusEvent) => {
        focused.value = true
      }
    }
    const blank = computed(() => {
      const val = inputValue.value
      return val === undefined || val === null || val === ''
    })
    const fieldAttrs = computed(() => ({
      blank: blank.value,
      class: ['of-field-textarea', props.class],
      config,
      disabled: disabled.value,
      focused: focused.value,
      inputId: id,
      label: config.label,
      readonly: readonly.value,
      store,
      variant: props.variant
    }))
    return {
      attrs: computed(() => ({
        id,
        class: 'of-field-input',
        disabled: disabled.value,
        placeholder: props.placeholder || config.placeholder,
        readonly: readonly.value,
        rows: props.rows
      })),
      elt,
      fieldAttrs,
      handlers,
      inputValue
    }
  }
})
</script>
