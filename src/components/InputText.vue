<template>
  <field-outer v-bind="fieldAttrs">
    <input ref="elt" v-bind="attrs" v-on="handlers" />
  </field-outer>
</template>

<script lang="ts">
import {
  ref,
  defineComponent,
  SetupContext,
  reactive,
  computed,
  Ref,
  watch
} from 'vue'
import { FieldConfig, FieldState, fieldState } from '../lib/field'
import FieldOuter from './FieldOuter.vue'
import { StoreRef, storeRef } from '../lib/store'
import { hasOwn } from '../lib/util'

const copyAttrs = new Set([
  'autocomplete',
  'placeholder',
  'size',
  'tabIndex',
  'value'
])

const mapStateAttrs = {
  id: 'inputId',
  class: 'inputClass',
  maxlength: 'maxLength',
  readonly: 'readOnly',
  required: 'required',
  style: 'inputStyle',
  tabindex: 'tabIndex',
  type: 'inputType',
  variant: 'inputVariant'
}

// types that can be inherited from state.type
// setting state.inputType allows any value
const allowInputTypes = new Set([
  'date',
  'datetime-local',
  'email',
  'month',
  'number',
  'password',
  'tel',
  'time',
  'week',
  'url'
])

const inputTypeFrom = (type?: string) => {
  if (type && allowInputTypes.has(type)) return type
  return 'text'
}

const variantClasses: Record<string, string> = {
  default: 'input-text',
  plain: ''
}

const makeAttrs = (
  config: FieldConfig,
  id: string,
  attrs: Record<string, any>
) => {
  const result: Record<string, any> = {}
  /*for (const k of copyAttrs) {
    const v = state[k] as any
    if (v !== undefined) result[k] = v
  }
  if (state.disabled) {
    result['disabled'] = true
  } else if (state.readOnly || state.store.locked) {
    result['readOnly'] = true
  }
  result['id'] = state.inputId
  result['class'] = [
    variantClasses[(state.inputVariant || 'default') as string],
    state.inputClass
  ]
  result['style'] = state.inputStyle
  result['type'] = state.inputType || inputTypeFrom(state.type)*/
  result['id'] = id
  result['class'] = 'field-input field-text'
  return result
}

const loadContextAttrs = (attrs: Record<string, any>, state: FieldState) => {
  if (!attrs) return
  const result = {}
  for (const k in attrs) {
    if (k === 'config' || k === 'store' || k === 'value') continue
    if (hasOwn(mapStateAttrs, k)) {
      // FIXME may want to merge values, inputClass/Style can hold a list
      state[mapStateAttrs[k]] = attrs[k]
    } else {
      if (!state.inputAttrs) state.inputAttrs = {}
      state.inputAttrs[k] = attrs[k]
    }
  }
}

export default defineComponent({
  name: 'input-text',
  components: { FieldOuter },
  inheritAttrs: false,
  async setup(
    props: {
      class?: string // or object or list
      config?: FieldConfig
      disabled?: boolean
      id?: string
      label?: string
      maxlength?: number
      modelValue?: string
      placeholder?: string
      readonly?: boolean
      store?: StoreRef
      tabindex?: number
      value?: string
      variant?: string
      [key: string]: any
    },
    ctx: SetupContext
  ) {
    const config = props.config || {}
    const inputValue = ref(props.modelValue)
    const store = props.store || storeRef(inputValue.value) // FIXME
    watch(
      () => props.modelValue,
      val => {
        inputValue.value = val
        store.value = val // unformat
      }
    )
    const elt = ref<HTMLInputElement>()
    const disabled = computed(() => config.disabled || props.disabled)
    const focused = ref(false)
    const readonly = computed(
      () => (config.readonly || props.readonly) && !disabled.value
    )
    const id =
      props.id || config.id || 'input-' + Math.round(Math.random() * 1000) // FIXME
    const value: Ref<any> = computed({
      get: () => {
        // FIXME format stored value
        // computed() can be generated by the formatter
        store.value
      },
      set: (val: any) => {
        // FIXME unformat value
        store.value = val
      }
    })
    const handlers = {
      blur: (evt: FocusEvent) => {
        focused.value = false
        ctx.emit('blur')
      },
      change: (evt: Event) => {
        inputValue.value = elt.value.value
        store.value = elt.value.value
        ctx.emit('change', inputValue.value)
      },
      focus: (evt: FocusEvent) => {
        focused.value = true
        ctx.emit('focus')
      },
      input: (evt: InputEvent) => {
        inputValue.value = elt.value.value
        ctx.emit('input', inputValue.value)
        ctx.emit('update:modelValue', inputValue.value)
      },
      keydown: (evt: KeyboardEvent) => {
        ctx.emit('keydown', evt)
      }
    }
    const blank = computed(() => {
      // FIXME ask formatter
      const val = inputValue.value
      return val === undefined || val === null || val === ''
    })
    const fieldAttrs = computed(() => ({
      blank: blank.value,
      class: ['field-text', props.class],
      config,
      disabled: disabled.value,
      focused: focused.value,
      inputId: id,
      label: props.label === undefined ? config.label : props.label,
      readonly: readonly.value,
      store,
      variant: props.variant
    }))
    return {
      attrs: computed(() => ({
        id,
        class: 'field-input',
        disabled: disabled.value,
        maxlength: props.maxlength || config.maxlength,
        placeholder: props.placeholder || config.placeholder,
        readonly: readonly.value,
        tabIndex: props.tabindex,
        value: inputValue.value
      })),
      elt,
      fieldAttrs,
      handlers
    }
  }
})
</script>
